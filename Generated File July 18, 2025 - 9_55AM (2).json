[
  {
    "name": "Quick Sort",
    "type": "Sorting",
    "time_complexity": "O(n log n) average, O(nÂ²) worst",
    "space_complexity": "O(log n)",
    "description": "Divide-and-conquer sorting algorithm",
    "implementation": "def quicksort(arr):\n    if len(arr) <= 1: return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quicksort(left) + middle + quicksort(right)",
    "use_cases": [
      "General purpose sorting",
      "In-place sorting when memory is limited"
    ],
    "source": "algorithm_collection",
    "collected_at": "2025-07-18T08:54:04.608607"
  },
  {
    "name": "Merge Sort",
    "type": "Sorting",
    "time_complexity": "O(n log n)",
    "space_complexity": "O(n)",
    "description": "Stable divide-and-conquer sorting algorithm",
    "implementation": "def mergesort(arr):\n    if len(arr) <= 1: return arr\n    mid = len(arr) // 2\n    left = mergesort(arr[:mid])\n    right = mergesort(arr[mid:])\n    # ... (merge logic)",
    "use_cases": [
      "When stability is required",
      "External sorting"
    ],
    "source": "algorithm_collection",
    "collected_at": "2025-07-18T08:54:04.608645"
  }
]