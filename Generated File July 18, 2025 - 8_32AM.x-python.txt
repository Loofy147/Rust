
import enum
import logging
import uuid
import time
from collections import deque
import json

# --- 1. Configuration initiale du Logging ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - [%(name)s] - %(message)s')

# --- 2. Énumérations pour les états et les capacités ---
class AgentCapability(enum.Enum):
    DATA_PROCESSING = 'data_processing'
    ORCHESTRATION = 'orchestration'

class AgentState(enum.Enum):
    IDLE = 'IDLE'
    BUSY = 'BUSY'
    FINISHED = 'FINISHED'
    ERROR = 'ERROR'

class TaskStatus(enum.Enum):
    PENDING = 'PENDING'
    IN_PROGRESS = 'IN_PROGRESS'
    COMPLETED = 'COMPLETED'
    FAILED = 'FAILED'

# --- 3. Classe de gestion des Tâches Structurées ---
class Task:
    def __init__(self, description: str, target_capability: AgentCapability, priority: int = 0, data: dict = None, task_id=None, history=None):
        self.task_id = task_id if task_id else str(uuid.uuid4())
        self.description = description
        self.target_capability = target_capability
        self.priority = priority
        self.data = data if data is not None else {}
        self.status = TaskStatus.PENDING
        self.result = None
        self.history = history if history else [f"Task {self.task_id} created."]
        if not history:
             logging.info(f"New Task created: {self.task_id} ('{self.description}')")

    def update_status(self, status: TaskStatus, message: str = ""):
        self.status = status
        log_message = f"Task {self.task_id} status updated to {status.value}."
        if message:
            log_message += f" Details: {message}"
        self.history.append(log_message)
        logging.info(log_message)
    
    def to_dict(self):
        return {
            "task_id": self.task_id,
            "description": self.description,
            "target_capability": self.target_capability.value,
            "priority": self.priority,
            "data": self.data,
            "status": self.status.value,
            "result": self.result,
            "history": self.history
        }

    @classmethod
    def from_dict(cls, data_dict):
        return cls(
            description=data_dict['description'],
            target_capability=AgentCapability(data_dict['target_capability']),
            priority=data_dict['priority'],
            data=data_dict['data'],
            task_id=data_dict['task_id'],
            history=data_dict['history']
        )

    def __repr__(self):
        return f"<Task(id={self.task_id}, status={self.status.value}, desc='{self.description}')>"

# --- 4. Le Bus de Messages Centralisé ---
class MessageBus:
    def __init__(self):
        self.messages = deque()
        self.subscribers = {}
        logging.info("MessageBus initialized.")

    def subscribe(self, agent):
        self.subscribers[agent.agent_id] = agent
        logging.info(f"Agent {agent.agent_id} subscribed to MessageBus.")

    def publish(self, sender_id: str, recipient_id: str, message: dict):
        full_message = {
            "sender_id": sender_id,
            "recipient_id": recipient_id,
            "content": message
        }
        self.messages.append(full_message)
        logging.info(f"Message published from {sender_id} to {recipient_id}.")

    def route_messages(self):
        while self.messages:
            message = self.messages.popleft()
            recipient = self.subscribers.get(message["recipient_id"])
            if recipient:
                recipient.inbox.append(message)
                logging.info(f"Message routed to {recipient.agent_id}'s inbox.")
            else:
                logging.warning(f"Message for {message['recipient_id']} dropped, no such subscriber.")

# --- 5. Classe de Base de l'Agent Améliorée ---
class Agent:
    def __init__(self, agent_id: str, capabilities: list[AgentCapability], message_bus: 'MessageBus'):
        self.agent_id = agent_id
        self.capabilities = capabilities
        self.state = AgentState.IDLE
        self.inbox = deque()
        self.message_bus = message_bus
        self.logger = logging.getLogger(self.agent_id)
        self.current_task = None
        
        self.message_bus.subscribe(self)
        self.logger.info(f"Initialized with capabilities: {[c.value for c in capabilities]}")

    def receive_message(self):
        if self.inbox:
            message = self.inbox.popleft()
            self.logger.info(f"Received message")
            self.process_message(message['content'])

    def lifecycle_step(self):
        self.receive_message()
        if self.state == AgentState.BUSY and self.current_task:
            self.execute_task()

    def process_message(self, message: dict):
        raise NotImplementedError

    def execute_task(self):
        raise NotImplementedError

    def set_state(self, new_state: AgentState):
        if self.state != new_state:
            self.state = new_state
            self.logger.info(f"State changed to {self.state.value}")
    
    def __repr__(self):
        return f"<Agent(id={self.agent_id}, state={self.state.value})>"

# --- 6. Agent Orchestrateur Amélioré ---
class OrchestrationAgent(Agent):
    def __init__(self, agent_id: str, message_bus: 'MessageBus'):
        super().__init__(agent_id, [AgentCapability.ORCHESTRATION], message_bus)
        self.registered_agents = {}
        self.active_tasks = {}

    def deploy_agent(self, agent_class: type, agent_id: str, capabilities: list[AgentCapability]):
        self.logger.info(f"Deploying agent {agent_id}...")
        agent_instance = agent_class(agent_id, capabilities, self.message_bus)
        self.registered_agents[agent_id] = agent_instance
        self.logger.info(f"Agent {agent_id} successfully deployed.")
        return agent_instance

    def assign_task(self, task: Task):
        eligible_agents = [
            agent for agent in self.registered_agents.values() 
            if task.target_capability in agent.capabilities and agent.state == AgentState.IDLE
        ]
        if not eligible_agents:
            self.logger.warning(f"No IDLE agent for capability {task.target_capability.value}. Task pending.")
            return

        agent_to_assign = eligible_agents[0]
        task.update_status(TaskStatus.IN_PROGRESS, f"Assigned to {agent_to_assign.agent_id}")
        self.active_tasks[task.task_id] = task
        
        message = {"type": "new_task", "task_data": task.to_dict()}
        self.message_bus.publish(self.agent_id, agent_to_assign.agent_id, message)

    def process_message(self, message: dict):
        msg_type = message.get("type")
        if msg_type == "task_result":
            task_data = message.get("task_data")
            task_id = task_data.get('task_id')
            if task_id in self.active_tasks:
                self.logger.info(f"Received result for task {task_id}: {task_data['status']}")
                self.active_tasks[task_id] = Task.from_dict(task_data)
                if self.active_tasks[task_id].status == TaskStatus.FAILED:
                    self.logger.error(f"Task {task_id} failed. Reason: {self.active_tasks[task_id].result}")

    def execute_workflow(self, workflow_description: str):
        self.logger.info(f"Executing workflow: '{workflow_description}'")
        if "process data file" in workflow_description:
            data_task = Task(
                description="Process customer_data.csv",
                target_capability=AgentCapability.DATA_PROCESSING,
                data={"filepath": "/path/to/customer_data.csv"}
            )
            self.assign_task(data_task)
    
    def lifecycle_step(self):
        self.receive_message()

# --- 7. Un Agent Spécialisé Concret ---
class DataProcessingAgent(Agent):
    def process_message(self, message: dict):
        if message.get("type") == "new_task":
            if self.state == AgentState.IDLE:
                task_data = message.get("task_data")
                self.current_task = Task.from_dict(task_data)
                self.set_state(AgentState.BUSY)
                self.logger.info(f"Accepted task {self.current_task.task_id}.")
            else:
                self.logger.warning(f"Received task but I am BUSY. Ignoring.")

    def execute_task(self):
        if self.current_task:
            task = self.current_task
            try:
                self.logger.info(f"Executing data processing for task {task.task_id}...")
                time.sleep(1) 
                if not task.data.get("filepath"):
                    raise ValueError("Filepath is missing.")
                
                task.result = {"lines_processed": 1000, "anomalies_found": 15}
                task.update_status(TaskStatus.COMPLETED, "Data processed successfully.")
                self.set_state(AgentState.FINISHED)

            except Exception as e:
                self.logger.error(f"Task {task.task_id} failed: {e}", exc_info=True)
                task.update_status(TaskStatus.FAILED, str(e))
                task.result = {"error": str(e)}
                self.set_state(AgentState.ERROR)

            result_message = {"type": "task_result", "task_data": task.to_dict()}
            self.message_bus.publish(self.agent_id, "Orchestrator", result_message)
            self.current_task = None
            self.set_state(AgentState.IDLE)

# --- Point d'entrée pour la démonstration ---
if __name__ == "__main__":
    import sys
    # Reconfigure logger for clear demonstration
    logging.getLogger().handlers.clear()
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - [%(name)s] - %(message)s'))
    logging.getLogger().addHandler(handler)
    logging.getLogger().setLevel(logging.INFO)

    print("--- Multi-Agent System Simulation ---")
    
    bus = MessageBus()
    orchestrator = OrchestrationAgent(agent_id="Orchestrator", message_bus=bus)
    data_agent_1 = orchestrator.deploy_agent(DataProcessingAgent, "DataProcessor-001", [AgentCapability.DATA_PROCESSING])
    orchestrator.execute_workflow("process data file for analysis")
    
    print("\n--- Starting System Lifecycle Simulation (5 steps) ---")
    for step in range(5):
        print(f"\n--- STEP {step+1} ---")
        bus.route_messages()
        orchestrator.lifecycle_step()
        data_agent_1.lifecycle_step()
        time.sleep(0.5) 
        
    print("\n--- Simulation Finished ---")
    final_task = list(orchestrator.active_tasks.values())[0]
    print(f"Final Task State: {final_task}")
    print(f"Final Task Result: {final_task.result}")
