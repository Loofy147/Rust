use async_trait::async_trait;
use serde_json;
use thiserror::Error;

#[cfg(feature = "llm-apis")]
use reqwest;

use crate::agent::prompt::PromptContext;
use crate::plugins::llm::mock::{LLMRequest, LLMResponse};

#[derive(Error, Debug)]
pub enum PluginError {
    #[cfg(feature = "llm-apis")]
    #[error("Network error: {0}")]
    Network(#[from] reqwest::Error),
    #[error("API error: {0}")]
    Api(String),
    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),
    #[error("Configuration error: {0}")]
    Configuration(String),
}

/// Plugin trait for LLM interactions - allows swapping between different LLM providers
#[async_trait]
pub trait LLMPlugin: Send + Sync {
    async fn generate(&self, request: &LLMRequest) -> Result<LLMResponse, PluginError>;
    fn get_model_name(&self) -> String;
}

/// Plugin trait for prompt building - allows customizing prompt construction
#[async_trait]
pub trait PromptBuilderPlugin: Send + Sync {
    async fn build_prompt(&self, context: &PromptContext) -> anyhow::Result<String>;
}

/// Mock LLM plugin for testing
pub struct MockLLMPlugin {
    model_name: String,
}

impl MockLLMPlugin {
    pub fn new() -> Self {
        Self {
            model_name: "mock-llm-v1".to_string(),
        }
    }
}

#[async_trait]
impl LLMPlugin for MockLLMPlugin {
    async fn generate(&self, request: &LLMRequest) -> Result<LLMResponse, PluginError> {
        // Simulate processing delay
        tokio::time::sleep(std::time::Duration::from_millis(100)).await;

        let response_content = format!(
            "Mock response to: {}\n\nBased on the provided context, this is a simulated answer that demonstrates the ReasoningAgent's capabilities. In a real implementation, this would be generated by an actual LLM like GPT-4 or Claude.",
            request.prompt.chars().take(100).collect::<String>()
        );

        Ok(LLMResponse {
            content: response_content,
            tokens_used: Some(150),
            model: self.model_name.clone(),
        })
    }

    fn get_model_name(&self) -> String {
        self.model_name.clone()
    }
}
